// Code generated by entc, DO NOT EDIT.

package ent

import (
	"fmt"
	"strings"
	"time"

	"github.com/facebookincubator/ent/dialect/sql"
)

// Planet is the model entity for the Planet schema.
type Planet struct {
	config `json:"-"`
	// ID of the ent.
	ID int `json:"id,omitempty"`
	// CreatedAt holds the value of the "created_at" field.
	CreatedAt time.Time `json:"created_at,omitempty"`
	// UpdatedAt holds the value of the "updated_at" field.
	UpdatedAt time.Time `json:"updated_at,omitempty"`
	// MetalStock holds the value of the "metal_stock" field.
	MetalStock int64 `json:"metal_stock,omitempty"`
	// MetalMine holds the value of the "metal_mine" field.
	MetalMine int `json:"metal_mine,omitempty"`
	// LastMetalUpdate holds the value of the "last_metal_update" field.
	LastMetalUpdate time.Time `json:"last_metal_update,omitempty"`
}

// FromRows scans the sql response data into Planet.
func (pl *Planet) FromRows(rows *sql.Rows) error {
	var scanpl struct {
		ID              int
		CreatedAt       sql.NullTime
		UpdatedAt       sql.NullTime
		MetalStock      sql.NullInt64
		MetalMine       sql.NullInt64
		LastMetalUpdate sql.NullTime
	}
	// the order here should be the same as in the `planet.Columns`.
	if err := rows.Scan(
		&scanpl.ID,
		&scanpl.CreatedAt,
		&scanpl.UpdatedAt,
		&scanpl.MetalStock,
		&scanpl.MetalMine,
		&scanpl.LastMetalUpdate,
	); err != nil {
		return err
	}
	pl.ID = scanpl.ID
	pl.CreatedAt = scanpl.CreatedAt.Time
	pl.UpdatedAt = scanpl.UpdatedAt.Time
	pl.MetalStock = scanpl.MetalStock.Int64
	pl.MetalMine = int(scanpl.MetalMine.Int64)
	pl.LastMetalUpdate = scanpl.LastMetalUpdate.Time
	return nil
}

// QueryOwner queries the owner edge of the Planet.
func (pl *Planet) QueryOwner() *UserQuery {
	return (&PlanetClient{pl.config}).QueryOwner(pl)
}

// Update returns a builder for updating this Planet.
// Note that, you need to call Planet.Unwrap() before calling this method, if this Planet
// was returned from a transaction, and the transaction was committed or rolled back.
func (pl *Planet) Update() *PlanetUpdateOne {
	return (&PlanetClient{pl.config}).UpdateOne(pl)
}

// Unwrap unwraps the entity that was returned from a transaction after it was closed,
// so that all next queries will be executed through the driver which created the transaction.
func (pl *Planet) Unwrap() *Planet {
	tx, ok := pl.config.driver.(*txDriver)
	if !ok {
		panic("ent: Planet is not a transactional entity")
	}
	pl.config.driver = tx.drv
	return pl
}

// String implements the fmt.Stringer.
func (pl *Planet) String() string {
	var builder strings.Builder
	builder.WriteString("Planet(")
	builder.WriteString(fmt.Sprintf("id=%v", pl.ID))
	builder.WriteString(", created_at=")
	builder.WriteString(pl.CreatedAt.Format(time.ANSIC))
	builder.WriteString(", updated_at=")
	builder.WriteString(pl.UpdatedAt.Format(time.ANSIC))
	builder.WriteString(", metal_stock=")
	builder.WriteString(fmt.Sprintf("%v", pl.MetalStock))
	builder.WriteString(", metal_mine=")
	builder.WriteString(fmt.Sprintf("%v", pl.MetalMine))
	builder.WriteString(", last_metal_update=")
	builder.WriteString(pl.LastMetalUpdate.Format(time.ANSIC))
	builder.WriteByte(')')
	return builder.String()
}

// Planets is a parsable slice of Planet.
type Planets []*Planet

// FromRows scans the sql response data into Planets.
func (pl *Planets) FromRows(rows *sql.Rows) error {
	for rows.Next() {
		scanpl := &Planet{}
		if err := scanpl.FromRows(rows); err != nil {
			return err
		}
		*pl = append(*pl, scanpl)
	}
	return nil
}

func (pl Planets) config(cfg config) {
	for _i := range pl {
		pl[_i].config = cfg
	}
}
