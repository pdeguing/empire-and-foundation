// Code generated by entc, DO NOT EDIT.

package ent

import (
	"fmt"
	"time"

	"github.com/pdeguing/empire-and-foundation/ent/planet"
	"github.com/pdeguing/empire-and-foundation/ent/session"
	"github.com/pdeguing/empire-and-foundation/ent/timer"
	"github.com/pdeguing/empire-and-foundation/ent/user"

	"github.com/facebookincubator/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypePlanet  = "Planet"
	TypeSession = "Session"
	TypeTimer   = "Timer"
	TypeUser    = "User"
)

// PlanetMutation represents an operation that mutate the Planets
// nodes in the graph.
type PlanetMutation struct {
	config
	op                          Op
	typ                         string
	id                          *int
	created_at                  *time.Time
	updated_at                  *time.Time
	metal                       *int64
	addmetal                    *int64
	metal_prod_level            *int
	addmetal_prod_level         *int
	metal_storage_level         *int
	addmetal_storage_level      *int
	hydrogen                    *int64
	addhydrogen                 *int64
	hydrogen_prod_level         *int
	addhydrogen_prod_level      *int
	hydrogen_storage_level      *int
	addhydrogen_storage_level   *int
	silica                      *int64
	addsilica                   *int64
	silica_prod_level           *int
	addsilica_prod_level        *int
	silica_storage_level        *int
	addsilica_storage_level     *int
	population                  *int64
	addpopulation               *int64
	population_prod_level       *int
	addpopulation_prod_level    *int
	population_storage_level    *int
	addpopulation_storage_level *int
	solar_prod_level            *int
	addsolar_prod_level         *int
	ship_factory_level          *int
	addship_factory_level       *int
	research_center_level       *int
	addresearch_center_level    *int
	region_code                 *int
	addregion_code              *int
	system_code                 *int
	addsystem_code              *int
	orbit_code                  *int
	addorbit_code               *int
	suborbit_code               *int
	addsuborbit_code            *int
	position_code               *int
	addposition_code            *int
	name                        *string
	planet_type                 *planet.PlanetType
	planet_skin                 *string
	last_resource_update        *time.Time
	clearedFields               map[string]struct{}
	owner                       *int
	clearedowner                bool
	timers                      map[int]struct{}
	removedtimers               map[int]struct{}
}

var _ ent.Mutation = (*PlanetMutation)(nil)

// newPlanetMutation creates new mutation for $n.Name.
func newPlanetMutation(c config, op Op) *PlanetMutation {
	return &PlanetMutation{
		config:        c,
		op:            op,
		typ:           TypePlanet,
		clearedFields: make(map[string]struct{}),
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PlanetMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PlanetMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PlanetMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the created_at field.
func (m *PlanetMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *PlanetMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt reset all changes of the created_at field.
func (m *PlanetMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the updated_at field.
func (m *PlanetMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the updated_at value in the mutation.
func (m *PlanetMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt reset all changes of the updated_at field.
func (m *PlanetMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetMetal sets the metal field.
func (m *PlanetMutation) SetMetal(i int64) {
	m.metal = &i
	m.addmetal = nil
}

// Metal returns the metal value in the mutation.
func (m *PlanetMutation) Metal() (r int64, exists bool) {
	v := m.metal
	if v == nil {
		return
	}
	return *v, true
}

// AddMetal adds i to metal.
func (m *PlanetMutation) AddMetal(i int64) {
	if m.addmetal != nil {
		*m.addmetal += i
	} else {
		m.addmetal = &i
	}
}

// AddedMetal returns the value that was added to the metal field in this mutation.
func (m *PlanetMutation) AddedMetal() (r int64, exists bool) {
	v := m.addmetal
	if v == nil {
		return
	}
	return *v, true
}

// ResetMetal reset all changes of the metal field.
func (m *PlanetMutation) ResetMetal() {
	m.metal = nil
	m.addmetal = nil
}

// SetMetalProdLevel sets the metal_prod_level field.
func (m *PlanetMutation) SetMetalProdLevel(i int) {
	m.metal_prod_level = &i
	m.addmetal_prod_level = nil
}

// MetalProdLevel returns the metal_prod_level value in the mutation.
func (m *PlanetMutation) MetalProdLevel() (r int, exists bool) {
	v := m.metal_prod_level
	if v == nil {
		return
	}
	return *v, true
}

// AddMetalProdLevel adds i to metal_prod_level.
func (m *PlanetMutation) AddMetalProdLevel(i int) {
	if m.addmetal_prod_level != nil {
		*m.addmetal_prod_level += i
	} else {
		m.addmetal_prod_level = &i
	}
}

// AddedMetalProdLevel returns the value that was added to the metal_prod_level field in this mutation.
func (m *PlanetMutation) AddedMetalProdLevel() (r int, exists bool) {
	v := m.addmetal_prod_level
	if v == nil {
		return
	}
	return *v, true
}

// ResetMetalProdLevel reset all changes of the metal_prod_level field.
func (m *PlanetMutation) ResetMetalProdLevel() {
	m.metal_prod_level = nil
	m.addmetal_prod_level = nil
}

// SetMetalStorageLevel sets the metal_storage_level field.
func (m *PlanetMutation) SetMetalStorageLevel(i int) {
	m.metal_storage_level = &i
	m.addmetal_storage_level = nil
}

// MetalStorageLevel returns the metal_storage_level value in the mutation.
func (m *PlanetMutation) MetalStorageLevel() (r int, exists bool) {
	v := m.metal_storage_level
	if v == nil {
		return
	}
	return *v, true
}

// AddMetalStorageLevel adds i to metal_storage_level.
func (m *PlanetMutation) AddMetalStorageLevel(i int) {
	if m.addmetal_storage_level != nil {
		*m.addmetal_storage_level += i
	} else {
		m.addmetal_storage_level = &i
	}
}

// AddedMetalStorageLevel returns the value that was added to the metal_storage_level field in this mutation.
func (m *PlanetMutation) AddedMetalStorageLevel() (r int, exists bool) {
	v := m.addmetal_storage_level
	if v == nil {
		return
	}
	return *v, true
}

// ResetMetalStorageLevel reset all changes of the metal_storage_level field.
func (m *PlanetMutation) ResetMetalStorageLevel() {
	m.metal_storage_level = nil
	m.addmetal_storage_level = nil
}

// SetHydrogen sets the hydrogen field.
func (m *PlanetMutation) SetHydrogen(i int64) {
	m.hydrogen = &i
	m.addhydrogen = nil
}

// Hydrogen returns the hydrogen value in the mutation.
func (m *PlanetMutation) Hydrogen() (r int64, exists bool) {
	v := m.hydrogen
	if v == nil {
		return
	}
	return *v, true
}

// AddHydrogen adds i to hydrogen.
func (m *PlanetMutation) AddHydrogen(i int64) {
	if m.addhydrogen != nil {
		*m.addhydrogen += i
	} else {
		m.addhydrogen = &i
	}
}

// AddedHydrogen returns the value that was added to the hydrogen field in this mutation.
func (m *PlanetMutation) AddedHydrogen() (r int64, exists bool) {
	v := m.addhydrogen
	if v == nil {
		return
	}
	return *v, true
}

// ResetHydrogen reset all changes of the hydrogen field.
func (m *PlanetMutation) ResetHydrogen() {
	m.hydrogen = nil
	m.addhydrogen = nil
}

// SetHydrogenProdLevel sets the hydrogen_prod_level field.
func (m *PlanetMutation) SetHydrogenProdLevel(i int) {
	m.hydrogen_prod_level = &i
	m.addhydrogen_prod_level = nil
}

// HydrogenProdLevel returns the hydrogen_prod_level value in the mutation.
func (m *PlanetMutation) HydrogenProdLevel() (r int, exists bool) {
	v := m.hydrogen_prod_level
	if v == nil {
		return
	}
	return *v, true
}

// AddHydrogenProdLevel adds i to hydrogen_prod_level.
func (m *PlanetMutation) AddHydrogenProdLevel(i int) {
	if m.addhydrogen_prod_level != nil {
		*m.addhydrogen_prod_level += i
	} else {
		m.addhydrogen_prod_level = &i
	}
}

// AddedHydrogenProdLevel returns the value that was added to the hydrogen_prod_level field in this mutation.
func (m *PlanetMutation) AddedHydrogenProdLevel() (r int, exists bool) {
	v := m.addhydrogen_prod_level
	if v == nil {
		return
	}
	return *v, true
}

// ResetHydrogenProdLevel reset all changes of the hydrogen_prod_level field.
func (m *PlanetMutation) ResetHydrogenProdLevel() {
	m.hydrogen_prod_level = nil
	m.addhydrogen_prod_level = nil
}

// SetHydrogenStorageLevel sets the hydrogen_storage_level field.
func (m *PlanetMutation) SetHydrogenStorageLevel(i int) {
	m.hydrogen_storage_level = &i
	m.addhydrogen_storage_level = nil
}

// HydrogenStorageLevel returns the hydrogen_storage_level value in the mutation.
func (m *PlanetMutation) HydrogenStorageLevel() (r int, exists bool) {
	v := m.hydrogen_storage_level
	if v == nil {
		return
	}
	return *v, true
}

// AddHydrogenStorageLevel adds i to hydrogen_storage_level.
func (m *PlanetMutation) AddHydrogenStorageLevel(i int) {
	if m.addhydrogen_storage_level != nil {
		*m.addhydrogen_storage_level += i
	} else {
		m.addhydrogen_storage_level = &i
	}
}

// AddedHydrogenStorageLevel returns the value that was added to the hydrogen_storage_level field in this mutation.
func (m *PlanetMutation) AddedHydrogenStorageLevel() (r int, exists bool) {
	v := m.addhydrogen_storage_level
	if v == nil {
		return
	}
	return *v, true
}

// ResetHydrogenStorageLevel reset all changes of the hydrogen_storage_level field.
func (m *PlanetMutation) ResetHydrogenStorageLevel() {
	m.hydrogen_storage_level = nil
	m.addhydrogen_storage_level = nil
}

// SetSilica sets the silica field.
func (m *PlanetMutation) SetSilica(i int64) {
	m.silica = &i
	m.addsilica = nil
}

// Silica returns the silica value in the mutation.
func (m *PlanetMutation) Silica() (r int64, exists bool) {
	v := m.silica
	if v == nil {
		return
	}
	return *v, true
}

// AddSilica adds i to silica.
func (m *PlanetMutation) AddSilica(i int64) {
	if m.addsilica != nil {
		*m.addsilica += i
	} else {
		m.addsilica = &i
	}
}

// AddedSilica returns the value that was added to the silica field in this mutation.
func (m *PlanetMutation) AddedSilica() (r int64, exists bool) {
	v := m.addsilica
	if v == nil {
		return
	}
	return *v, true
}

// ResetSilica reset all changes of the silica field.
func (m *PlanetMutation) ResetSilica() {
	m.silica = nil
	m.addsilica = nil
}

// SetSilicaProdLevel sets the silica_prod_level field.
func (m *PlanetMutation) SetSilicaProdLevel(i int) {
	m.silica_prod_level = &i
	m.addsilica_prod_level = nil
}

// SilicaProdLevel returns the silica_prod_level value in the mutation.
func (m *PlanetMutation) SilicaProdLevel() (r int, exists bool) {
	v := m.silica_prod_level
	if v == nil {
		return
	}
	return *v, true
}

// AddSilicaProdLevel adds i to silica_prod_level.
func (m *PlanetMutation) AddSilicaProdLevel(i int) {
	if m.addsilica_prod_level != nil {
		*m.addsilica_prod_level += i
	} else {
		m.addsilica_prod_level = &i
	}
}

// AddedSilicaProdLevel returns the value that was added to the silica_prod_level field in this mutation.
func (m *PlanetMutation) AddedSilicaProdLevel() (r int, exists bool) {
	v := m.addsilica_prod_level
	if v == nil {
		return
	}
	return *v, true
}

// ResetSilicaProdLevel reset all changes of the silica_prod_level field.
func (m *PlanetMutation) ResetSilicaProdLevel() {
	m.silica_prod_level = nil
	m.addsilica_prod_level = nil
}

// SetSilicaStorageLevel sets the silica_storage_level field.
func (m *PlanetMutation) SetSilicaStorageLevel(i int) {
	m.silica_storage_level = &i
	m.addsilica_storage_level = nil
}

// SilicaStorageLevel returns the silica_storage_level value in the mutation.
func (m *PlanetMutation) SilicaStorageLevel() (r int, exists bool) {
	v := m.silica_storage_level
	if v == nil {
		return
	}
	return *v, true
}

// AddSilicaStorageLevel adds i to silica_storage_level.
func (m *PlanetMutation) AddSilicaStorageLevel(i int) {
	if m.addsilica_storage_level != nil {
		*m.addsilica_storage_level += i
	} else {
		m.addsilica_storage_level = &i
	}
}

// AddedSilicaStorageLevel returns the value that was added to the silica_storage_level field in this mutation.
func (m *PlanetMutation) AddedSilicaStorageLevel() (r int, exists bool) {
	v := m.addsilica_storage_level
	if v == nil {
		return
	}
	return *v, true
}

// ResetSilicaStorageLevel reset all changes of the silica_storage_level field.
func (m *PlanetMutation) ResetSilicaStorageLevel() {
	m.silica_storage_level = nil
	m.addsilica_storage_level = nil
}

// SetPopulation sets the population field.
func (m *PlanetMutation) SetPopulation(i int64) {
	m.population = &i
	m.addpopulation = nil
}

// Population returns the population value in the mutation.
func (m *PlanetMutation) Population() (r int64, exists bool) {
	v := m.population
	if v == nil {
		return
	}
	return *v, true
}

// AddPopulation adds i to population.
func (m *PlanetMutation) AddPopulation(i int64) {
	if m.addpopulation != nil {
		*m.addpopulation += i
	} else {
		m.addpopulation = &i
	}
}

// AddedPopulation returns the value that was added to the population field in this mutation.
func (m *PlanetMutation) AddedPopulation() (r int64, exists bool) {
	v := m.addpopulation
	if v == nil {
		return
	}
	return *v, true
}

// ResetPopulation reset all changes of the population field.
func (m *PlanetMutation) ResetPopulation() {
	m.population = nil
	m.addpopulation = nil
}

// SetPopulationProdLevel sets the population_prod_level field.
func (m *PlanetMutation) SetPopulationProdLevel(i int) {
	m.population_prod_level = &i
	m.addpopulation_prod_level = nil
}

// PopulationProdLevel returns the population_prod_level value in the mutation.
func (m *PlanetMutation) PopulationProdLevel() (r int, exists bool) {
	v := m.population_prod_level
	if v == nil {
		return
	}
	return *v, true
}

// AddPopulationProdLevel adds i to population_prod_level.
func (m *PlanetMutation) AddPopulationProdLevel(i int) {
	if m.addpopulation_prod_level != nil {
		*m.addpopulation_prod_level += i
	} else {
		m.addpopulation_prod_level = &i
	}
}

// AddedPopulationProdLevel returns the value that was added to the population_prod_level field in this mutation.
func (m *PlanetMutation) AddedPopulationProdLevel() (r int, exists bool) {
	v := m.addpopulation_prod_level
	if v == nil {
		return
	}
	return *v, true
}

// ResetPopulationProdLevel reset all changes of the population_prod_level field.
func (m *PlanetMutation) ResetPopulationProdLevel() {
	m.population_prod_level = nil
	m.addpopulation_prod_level = nil
}

// SetPopulationStorageLevel sets the population_storage_level field.
func (m *PlanetMutation) SetPopulationStorageLevel(i int) {
	m.population_storage_level = &i
	m.addpopulation_storage_level = nil
}

// PopulationStorageLevel returns the population_storage_level value in the mutation.
func (m *PlanetMutation) PopulationStorageLevel() (r int, exists bool) {
	v := m.population_storage_level
	if v == nil {
		return
	}
	return *v, true
}

// AddPopulationStorageLevel adds i to population_storage_level.
func (m *PlanetMutation) AddPopulationStorageLevel(i int) {
	if m.addpopulation_storage_level != nil {
		*m.addpopulation_storage_level += i
	} else {
		m.addpopulation_storage_level = &i
	}
}

// AddedPopulationStorageLevel returns the value that was added to the population_storage_level field in this mutation.
func (m *PlanetMutation) AddedPopulationStorageLevel() (r int, exists bool) {
	v := m.addpopulation_storage_level
	if v == nil {
		return
	}
	return *v, true
}

// ResetPopulationStorageLevel reset all changes of the population_storage_level field.
func (m *PlanetMutation) ResetPopulationStorageLevel() {
	m.population_storage_level = nil
	m.addpopulation_storage_level = nil
}

// SetSolarProdLevel sets the solar_prod_level field.
func (m *PlanetMutation) SetSolarProdLevel(i int) {
	m.solar_prod_level = &i
	m.addsolar_prod_level = nil
}

// SolarProdLevel returns the solar_prod_level value in the mutation.
func (m *PlanetMutation) SolarProdLevel() (r int, exists bool) {
	v := m.solar_prod_level
	if v == nil {
		return
	}
	return *v, true
}

// AddSolarProdLevel adds i to solar_prod_level.
func (m *PlanetMutation) AddSolarProdLevel(i int) {
	if m.addsolar_prod_level != nil {
		*m.addsolar_prod_level += i
	} else {
		m.addsolar_prod_level = &i
	}
}

// AddedSolarProdLevel returns the value that was added to the solar_prod_level field in this mutation.
func (m *PlanetMutation) AddedSolarProdLevel() (r int, exists bool) {
	v := m.addsolar_prod_level
	if v == nil {
		return
	}
	return *v, true
}

// ResetSolarProdLevel reset all changes of the solar_prod_level field.
func (m *PlanetMutation) ResetSolarProdLevel() {
	m.solar_prod_level = nil
	m.addsolar_prod_level = nil
}

// SetShipFactoryLevel sets the ship_factory_level field.
func (m *PlanetMutation) SetShipFactoryLevel(i int) {
	m.ship_factory_level = &i
	m.addship_factory_level = nil
}

// ShipFactoryLevel returns the ship_factory_level value in the mutation.
func (m *PlanetMutation) ShipFactoryLevel() (r int, exists bool) {
	v := m.ship_factory_level
	if v == nil {
		return
	}
	return *v, true
}

// AddShipFactoryLevel adds i to ship_factory_level.
func (m *PlanetMutation) AddShipFactoryLevel(i int) {
	if m.addship_factory_level != nil {
		*m.addship_factory_level += i
	} else {
		m.addship_factory_level = &i
	}
}

// AddedShipFactoryLevel returns the value that was added to the ship_factory_level field in this mutation.
func (m *PlanetMutation) AddedShipFactoryLevel() (r int, exists bool) {
	v := m.addship_factory_level
	if v == nil {
		return
	}
	return *v, true
}

// ResetShipFactoryLevel reset all changes of the ship_factory_level field.
func (m *PlanetMutation) ResetShipFactoryLevel() {
	m.ship_factory_level = nil
	m.addship_factory_level = nil
}

// SetResearchCenterLevel sets the research_center_level field.
func (m *PlanetMutation) SetResearchCenterLevel(i int) {
	m.research_center_level = &i
	m.addresearch_center_level = nil
}

// ResearchCenterLevel returns the research_center_level value in the mutation.
func (m *PlanetMutation) ResearchCenterLevel() (r int, exists bool) {
	v := m.research_center_level
	if v == nil {
		return
	}
	return *v, true
}

// AddResearchCenterLevel adds i to research_center_level.
func (m *PlanetMutation) AddResearchCenterLevel(i int) {
	if m.addresearch_center_level != nil {
		*m.addresearch_center_level += i
	} else {
		m.addresearch_center_level = &i
	}
}

// AddedResearchCenterLevel returns the value that was added to the research_center_level field in this mutation.
func (m *PlanetMutation) AddedResearchCenterLevel() (r int, exists bool) {
	v := m.addresearch_center_level
	if v == nil {
		return
	}
	return *v, true
}

// ResetResearchCenterLevel reset all changes of the research_center_level field.
func (m *PlanetMutation) ResetResearchCenterLevel() {
	m.research_center_level = nil
	m.addresearch_center_level = nil
}

// SetRegionCode sets the region_code field.
func (m *PlanetMutation) SetRegionCode(i int) {
	m.region_code = &i
	m.addregion_code = nil
}

// RegionCode returns the region_code value in the mutation.
func (m *PlanetMutation) RegionCode() (r int, exists bool) {
	v := m.region_code
	if v == nil {
		return
	}
	return *v, true
}

// AddRegionCode adds i to region_code.
func (m *PlanetMutation) AddRegionCode(i int) {
	if m.addregion_code != nil {
		*m.addregion_code += i
	} else {
		m.addregion_code = &i
	}
}

// AddedRegionCode returns the value that was added to the region_code field in this mutation.
func (m *PlanetMutation) AddedRegionCode() (r int, exists bool) {
	v := m.addregion_code
	if v == nil {
		return
	}
	return *v, true
}

// ResetRegionCode reset all changes of the region_code field.
func (m *PlanetMutation) ResetRegionCode() {
	m.region_code = nil
	m.addregion_code = nil
}

// SetSystemCode sets the system_code field.
func (m *PlanetMutation) SetSystemCode(i int) {
	m.system_code = &i
	m.addsystem_code = nil
}

// SystemCode returns the system_code value in the mutation.
func (m *PlanetMutation) SystemCode() (r int, exists bool) {
	v := m.system_code
	if v == nil {
		return
	}
	return *v, true
}

// AddSystemCode adds i to system_code.
func (m *PlanetMutation) AddSystemCode(i int) {
	if m.addsystem_code != nil {
		*m.addsystem_code += i
	} else {
		m.addsystem_code = &i
	}
}

// AddedSystemCode returns the value that was added to the system_code field in this mutation.
func (m *PlanetMutation) AddedSystemCode() (r int, exists bool) {
	v := m.addsystem_code
	if v == nil {
		return
	}
	return *v, true
}

// ResetSystemCode reset all changes of the system_code field.
func (m *PlanetMutation) ResetSystemCode() {
	m.system_code = nil
	m.addsystem_code = nil
}

// SetOrbitCode sets the orbit_code field.
func (m *PlanetMutation) SetOrbitCode(i int) {
	m.orbit_code = &i
	m.addorbit_code = nil
}

// OrbitCode returns the orbit_code value in the mutation.
func (m *PlanetMutation) OrbitCode() (r int, exists bool) {
	v := m.orbit_code
	if v == nil {
		return
	}
	return *v, true
}

// AddOrbitCode adds i to orbit_code.
func (m *PlanetMutation) AddOrbitCode(i int) {
	if m.addorbit_code != nil {
		*m.addorbit_code += i
	} else {
		m.addorbit_code = &i
	}
}

// AddedOrbitCode returns the value that was added to the orbit_code field in this mutation.
func (m *PlanetMutation) AddedOrbitCode() (r int, exists bool) {
	v := m.addorbit_code
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrbitCode reset all changes of the orbit_code field.
func (m *PlanetMutation) ResetOrbitCode() {
	m.orbit_code = nil
	m.addorbit_code = nil
}

// SetSuborbitCode sets the suborbit_code field.
func (m *PlanetMutation) SetSuborbitCode(i int) {
	m.suborbit_code = &i
	m.addsuborbit_code = nil
}

// SuborbitCode returns the suborbit_code value in the mutation.
func (m *PlanetMutation) SuborbitCode() (r int, exists bool) {
	v := m.suborbit_code
	if v == nil {
		return
	}
	return *v, true
}

// AddSuborbitCode adds i to suborbit_code.
func (m *PlanetMutation) AddSuborbitCode(i int) {
	if m.addsuborbit_code != nil {
		*m.addsuborbit_code += i
	} else {
		m.addsuborbit_code = &i
	}
}

// AddedSuborbitCode returns the value that was added to the suborbit_code field in this mutation.
func (m *PlanetMutation) AddedSuborbitCode() (r int, exists bool) {
	v := m.addsuborbit_code
	if v == nil {
		return
	}
	return *v, true
}

// ResetSuborbitCode reset all changes of the suborbit_code field.
func (m *PlanetMutation) ResetSuborbitCode() {
	m.suborbit_code = nil
	m.addsuborbit_code = nil
}

// SetPositionCode sets the position_code field.
func (m *PlanetMutation) SetPositionCode(i int) {
	m.position_code = &i
	m.addposition_code = nil
}

// PositionCode returns the position_code value in the mutation.
func (m *PlanetMutation) PositionCode() (r int, exists bool) {
	v := m.position_code
	if v == nil {
		return
	}
	return *v, true
}

// AddPositionCode adds i to position_code.
func (m *PlanetMutation) AddPositionCode(i int) {
	if m.addposition_code != nil {
		*m.addposition_code += i
	} else {
		m.addposition_code = &i
	}
}

// AddedPositionCode returns the value that was added to the position_code field in this mutation.
func (m *PlanetMutation) AddedPositionCode() (r int, exists bool) {
	v := m.addposition_code
	if v == nil {
		return
	}
	return *v, true
}

// ResetPositionCode reset all changes of the position_code field.
func (m *PlanetMutation) ResetPositionCode() {
	m.position_code = nil
	m.addposition_code = nil
}

// SetName sets the name field.
func (m *PlanetMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *PlanetMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// ResetName reset all changes of the name field.
func (m *PlanetMutation) ResetName() {
	m.name = nil
}

// SetPlanetType sets the planet_type field.
func (m *PlanetMutation) SetPlanetType(pt planet.PlanetType) {
	m.planet_type = &pt
}

// PlanetType returns the planet_type value in the mutation.
func (m *PlanetMutation) PlanetType() (r planet.PlanetType, exists bool) {
	v := m.planet_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetPlanetType reset all changes of the planet_type field.
func (m *PlanetMutation) ResetPlanetType() {
	m.planet_type = nil
}

// SetPlanetSkin sets the planet_skin field.
func (m *PlanetMutation) SetPlanetSkin(s string) {
	m.planet_skin = &s
}

// PlanetSkin returns the planet_skin value in the mutation.
func (m *PlanetMutation) PlanetSkin() (r string, exists bool) {
	v := m.planet_skin
	if v == nil {
		return
	}
	return *v, true
}

// ResetPlanetSkin reset all changes of the planet_skin field.
func (m *PlanetMutation) ResetPlanetSkin() {
	m.planet_skin = nil
}

// SetLastResourceUpdate sets the last_resource_update field.
func (m *PlanetMutation) SetLastResourceUpdate(t time.Time) {
	m.last_resource_update = &t
}

// LastResourceUpdate returns the last_resource_update value in the mutation.
func (m *PlanetMutation) LastResourceUpdate() (r time.Time, exists bool) {
	v := m.last_resource_update
	if v == nil {
		return
	}
	return *v, true
}

// ResetLastResourceUpdate reset all changes of the last_resource_update field.
func (m *PlanetMutation) ResetLastResourceUpdate() {
	m.last_resource_update = nil
}

// SetOwnerID sets the owner edge to User by id.
func (m *PlanetMutation) SetOwnerID(id int) {
	m.owner = &id
}

// ClearOwner clears the owner edge to User.
func (m *PlanetMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared returns if the edge owner was cleared.
func (m *PlanetMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the owner id in the mutation.
func (m *PlanetMutation) OwnerID() (id int, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the owner ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *PlanetMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner reset all changes of the owner edge.
func (m *PlanetMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// AddTimerIDs adds the timers edge to Timer by ids.
func (m *PlanetMutation) AddTimerIDs(ids ...int) {
	if m.timers == nil {
		m.timers = make(map[int]struct{})
	}
	for i := range ids {
		m.timers[ids[i]] = struct{}{}
	}
}

// RemoveTimerIDs removes the timers edge to Timer by ids.
func (m *PlanetMutation) RemoveTimerIDs(ids ...int) {
	if m.removedtimers == nil {
		m.removedtimers = make(map[int]struct{})
	}
	for i := range ids {
		m.removedtimers[ids[i]] = struct{}{}
	}
}

// RemovedTimers returns the removed ids of timers.
func (m *PlanetMutation) RemovedTimersIDs() (ids []int) {
	for id := range m.removedtimers {
		ids = append(ids, id)
	}
	return
}

// TimersIDs returns the timers ids in the mutation.
func (m *PlanetMutation) TimersIDs() (ids []int) {
	for id := range m.timers {
		ids = append(ids, id)
	}
	return
}

// ResetTimers reset all changes of the timers edge.
func (m *PlanetMutation) ResetTimers() {
	m.timers = nil
	m.removedtimers = nil
}

// Op returns the operation name.
func (m *PlanetMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Planet).
func (m *PlanetMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PlanetMutation) Fields() []string {
	fields := make([]string, 0, 26)
	if m.created_at != nil {
		fields = append(fields, planet.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, planet.FieldUpdatedAt)
	}
	if m.metal != nil {
		fields = append(fields, planet.FieldMetal)
	}
	if m.metal_prod_level != nil {
		fields = append(fields, planet.FieldMetalProdLevel)
	}
	if m.metal_storage_level != nil {
		fields = append(fields, planet.FieldMetalStorageLevel)
	}
	if m.hydrogen != nil {
		fields = append(fields, planet.FieldHydrogen)
	}
	if m.hydrogen_prod_level != nil {
		fields = append(fields, planet.FieldHydrogenProdLevel)
	}
	if m.hydrogen_storage_level != nil {
		fields = append(fields, planet.FieldHydrogenStorageLevel)
	}
	if m.silica != nil {
		fields = append(fields, planet.FieldSilica)
	}
	if m.silica_prod_level != nil {
		fields = append(fields, planet.FieldSilicaProdLevel)
	}
	if m.silica_storage_level != nil {
		fields = append(fields, planet.FieldSilicaStorageLevel)
	}
	if m.population != nil {
		fields = append(fields, planet.FieldPopulation)
	}
	if m.population_prod_level != nil {
		fields = append(fields, planet.FieldPopulationProdLevel)
	}
	if m.population_storage_level != nil {
		fields = append(fields, planet.FieldPopulationStorageLevel)
	}
	if m.solar_prod_level != nil {
		fields = append(fields, planet.FieldSolarProdLevel)
	}
	if m.ship_factory_level != nil {
		fields = append(fields, planet.FieldShipFactoryLevel)
	}
	if m.research_center_level != nil {
		fields = append(fields, planet.FieldResearchCenterLevel)
	}
	if m.region_code != nil {
		fields = append(fields, planet.FieldRegionCode)
	}
	if m.system_code != nil {
		fields = append(fields, planet.FieldSystemCode)
	}
	if m.orbit_code != nil {
		fields = append(fields, planet.FieldOrbitCode)
	}
	if m.suborbit_code != nil {
		fields = append(fields, planet.FieldSuborbitCode)
	}
	if m.position_code != nil {
		fields = append(fields, planet.FieldPositionCode)
	}
	if m.name != nil {
		fields = append(fields, planet.FieldName)
	}
	if m.planet_type != nil {
		fields = append(fields, planet.FieldPlanetType)
	}
	if m.planet_skin != nil {
		fields = append(fields, planet.FieldPlanetSkin)
	}
	if m.last_resource_update != nil {
		fields = append(fields, planet.FieldLastResourceUpdate)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PlanetMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case planet.FieldCreatedAt:
		return m.CreatedAt()
	case planet.FieldUpdatedAt:
		return m.UpdatedAt()
	case planet.FieldMetal:
		return m.Metal()
	case planet.FieldMetalProdLevel:
		return m.MetalProdLevel()
	case planet.FieldMetalStorageLevel:
		return m.MetalStorageLevel()
	case planet.FieldHydrogen:
		return m.Hydrogen()
	case planet.FieldHydrogenProdLevel:
		return m.HydrogenProdLevel()
	case planet.FieldHydrogenStorageLevel:
		return m.HydrogenStorageLevel()
	case planet.FieldSilica:
		return m.Silica()
	case planet.FieldSilicaProdLevel:
		return m.SilicaProdLevel()
	case planet.FieldSilicaStorageLevel:
		return m.SilicaStorageLevel()
	case planet.FieldPopulation:
		return m.Population()
	case planet.FieldPopulationProdLevel:
		return m.PopulationProdLevel()
	case planet.FieldPopulationStorageLevel:
		return m.PopulationStorageLevel()
	case planet.FieldSolarProdLevel:
		return m.SolarProdLevel()
	case planet.FieldShipFactoryLevel:
		return m.ShipFactoryLevel()
	case planet.FieldResearchCenterLevel:
		return m.ResearchCenterLevel()
	case planet.FieldRegionCode:
		return m.RegionCode()
	case planet.FieldSystemCode:
		return m.SystemCode()
	case planet.FieldOrbitCode:
		return m.OrbitCode()
	case planet.FieldSuborbitCode:
		return m.SuborbitCode()
	case planet.FieldPositionCode:
		return m.PositionCode()
	case planet.FieldName:
		return m.Name()
	case planet.FieldPlanetType:
		return m.PlanetType()
	case planet.FieldPlanetSkin:
		return m.PlanetSkin()
	case planet.FieldLastResourceUpdate:
		return m.LastResourceUpdate()
	}
	return nil, false
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PlanetMutation) SetField(name string, value ent.Value) error {
	switch name {
	case planet.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case planet.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case planet.FieldMetal:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetal(v)
		return nil
	case planet.FieldMetalProdLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetalProdLevel(v)
		return nil
	case planet.FieldMetalStorageLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetalStorageLevel(v)
		return nil
	case planet.FieldHydrogen:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHydrogen(v)
		return nil
	case planet.FieldHydrogenProdLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHydrogenProdLevel(v)
		return nil
	case planet.FieldHydrogenStorageLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHydrogenStorageLevel(v)
		return nil
	case planet.FieldSilica:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSilica(v)
		return nil
	case planet.FieldSilicaProdLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSilicaProdLevel(v)
		return nil
	case planet.FieldSilicaStorageLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSilicaStorageLevel(v)
		return nil
	case planet.FieldPopulation:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPopulation(v)
		return nil
	case planet.FieldPopulationProdLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPopulationProdLevel(v)
		return nil
	case planet.FieldPopulationStorageLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPopulationStorageLevel(v)
		return nil
	case planet.FieldSolarProdLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSolarProdLevel(v)
		return nil
	case planet.FieldShipFactoryLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShipFactoryLevel(v)
		return nil
	case planet.FieldResearchCenterLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResearchCenterLevel(v)
		return nil
	case planet.FieldRegionCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegionCode(v)
		return nil
	case planet.FieldSystemCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemCode(v)
		return nil
	case planet.FieldOrbitCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrbitCode(v)
		return nil
	case planet.FieldSuborbitCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuborbitCode(v)
		return nil
	case planet.FieldPositionCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPositionCode(v)
		return nil
	case planet.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case planet.FieldPlanetType:
		v, ok := value.(planet.PlanetType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlanetType(v)
		return nil
	case planet.FieldPlanetSkin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlanetSkin(v)
		return nil
	case planet.FieldLastResourceUpdate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastResourceUpdate(v)
		return nil
	}
	return fmt.Errorf("unknown Planet field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PlanetMutation) AddedFields() []string {
	var fields []string
	if m.addmetal != nil {
		fields = append(fields, planet.FieldMetal)
	}
	if m.addmetal_prod_level != nil {
		fields = append(fields, planet.FieldMetalProdLevel)
	}
	if m.addmetal_storage_level != nil {
		fields = append(fields, planet.FieldMetalStorageLevel)
	}
	if m.addhydrogen != nil {
		fields = append(fields, planet.FieldHydrogen)
	}
	if m.addhydrogen_prod_level != nil {
		fields = append(fields, planet.FieldHydrogenProdLevel)
	}
	if m.addhydrogen_storage_level != nil {
		fields = append(fields, planet.FieldHydrogenStorageLevel)
	}
	if m.addsilica != nil {
		fields = append(fields, planet.FieldSilica)
	}
	if m.addsilica_prod_level != nil {
		fields = append(fields, planet.FieldSilicaProdLevel)
	}
	if m.addsilica_storage_level != nil {
		fields = append(fields, planet.FieldSilicaStorageLevel)
	}
	if m.addpopulation != nil {
		fields = append(fields, planet.FieldPopulation)
	}
	if m.addpopulation_prod_level != nil {
		fields = append(fields, planet.FieldPopulationProdLevel)
	}
	if m.addpopulation_storage_level != nil {
		fields = append(fields, planet.FieldPopulationStorageLevel)
	}
	if m.addsolar_prod_level != nil {
		fields = append(fields, planet.FieldSolarProdLevel)
	}
	if m.addship_factory_level != nil {
		fields = append(fields, planet.FieldShipFactoryLevel)
	}
	if m.addresearch_center_level != nil {
		fields = append(fields, planet.FieldResearchCenterLevel)
	}
	if m.addregion_code != nil {
		fields = append(fields, planet.FieldRegionCode)
	}
	if m.addsystem_code != nil {
		fields = append(fields, planet.FieldSystemCode)
	}
	if m.addorbit_code != nil {
		fields = append(fields, planet.FieldOrbitCode)
	}
	if m.addsuborbit_code != nil {
		fields = append(fields, planet.FieldSuborbitCode)
	}
	if m.addposition_code != nil {
		fields = append(fields, planet.FieldPositionCode)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PlanetMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case planet.FieldMetal:
		return m.AddedMetal()
	case planet.FieldMetalProdLevel:
		return m.AddedMetalProdLevel()
	case planet.FieldMetalStorageLevel:
		return m.AddedMetalStorageLevel()
	case planet.FieldHydrogen:
		return m.AddedHydrogen()
	case planet.FieldHydrogenProdLevel:
		return m.AddedHydrogenProdLevel()
	case planet.FieldHydrogenStorageLevel:
		return m.AddedHydrogenStorageLevel()
	case planet.FieldSilica:
		return m.AddedSilica()
	case planet.FieldSilicaProdLevel:
		return m.AddedSilicaProdLevel()
	case planet.FieldSilicaStorageLevel:
		return m.AddedSilicaStorageLevel()
	case planet.FieldPopulation:
		return m.AddedPopulation()
	case planet.FieldPopulationProdLevel:
		return m.AddedPopulationProdLevel()
	case planet.FieldPopulationStorageLevel:
		return m.AddedPopulationStorageLevel()
	case planet.FieldSolarProdLevel:
		return m.AddedSolarProdLevel()
	case planet.FieldShipFactoryLevel:
		return m.AddedShipFactoryLevel()
	case planet.FieldResearchCenterLevel:
		return m.AddedResearchCenterLevel()
	case planet.FieldRegionCode:
		return m.AddedRegionCode()
	case planet.FieldSystemCode:
		return m.AddedSystemCode()
	case planet.FieldOrbitCode:
		return m.AddedOrbitCode()
	case planet.FieldSuborbitCode:
		return m.AddedSuborbitCode()
	case planet.FieldPositionCode:
		return m.AddedPositionCode()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PlanetMutation) AddField(name string, value ent.Value) error {
	switch name {
	case planet.FieldMetal:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMetal(v)
		return nil
	case planet.FieldMetalProdLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMetalProdLevel(v)
		return nil
	case planet.FieldMetalStorageLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMetalStorageLevel(v)
		return nil
	case planet.FieldHydrogen:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHydrogen(v)
		return nil
	case planet.FieldHydrogenProdLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHydrogenProdLevel(v)
		return nil
	case planet.FieldHydrogenStorageLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHydrogenStorageLevel(v)
		return nil
	case planet.FieldSilica:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSilica(v)
		return nil
	case planet.FieldSilicaProdLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSilicaProdLevel(v)
		return nil
	case planet.FieldSilicaStorageLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSilicaStorageLevel(v)
		return nil
	case planet.FieldPopulation:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPopulation(v)
		return nil
	case planet.FieldPopulationProdLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPopulationProdLevel(v)
		return nil
	case planet.FieldPopulationStorageLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPopulationStorageLevel(v)
		return nil
	case planet.FieldSolarProdLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSolarProdLevel(v)
		return nil
	case planet.FieldShipFactoryLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddShipFactoryLevel(v)
		return nil
	case planet.FieldResearchCenterLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddResearchCenterLevel(v)
		return nil
	case planet.FieldRegionCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRegionCode(v)
		return nil
	case planet.FieldSystemCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSystemCode(v)
		return nil
	case planet.FieldOrbitCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrbitCode(v)
		return nil
	case planet.FieldSuborbitCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSuborbitCode(v)
		return nil
	case planet.FieldPositionCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPositionCode(v)
		return nil
	}
	return fmt.Errorf("unknown Planet numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PlanetMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PlanetMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PlanetMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Planet nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PlanetMutation) ResetField(name string) error {
	switch name {
	case planet.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case planet.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case planet.FieldMetal:
		m.ResetMetal()
		return nil
	case planet.FieldMetalProdLevel:
		m.ResetMetalProdLevel()
		return nil
	case planet.FieldMetalStorageLevel:
		m.ResetMetalStorageLevel()
		return nil
	case planet.FieldHydrogen:
		m.ResetHydrogen()
		return nil
	case planet.FieldHydrogenProdLevel:
		m.ResetHydrogenProdLevel()
		return nil
	case planet.FieldHydrogenStorageLevel:
		m.ResetHydrogenStorageLevel()
		return nil
	case planet.FieldSilica:
		m.ResetSilica()
		return nil
	case planet.FieldSilicaProdLevel:
		m.ResetSilicaProdLevel()
		return nil
	case planet.FieldSilicaStorageLevel:
		m.ResetSilicaStorageLevel()
		return nil
	case planet.FieldPopulation:
		m.ResetPopulation()
		return nil
	case planet.FieldPopulationProdLevel:
		m.ResetPopulationProdLevel()
		return nil
	case planet.FieldPopulationStorageLevel:
		m.ResetPopulationStorageLevel()
		return nil
	case planet.FieldSolarProdLevel:
		m.ResetSolarProdLevel()
		return nil
	case planet.FieldShipFactoryLevel:
		m.ResetShipFactoryLevel()
		return nil
	case planet.FieldResearchCenterLevel:
		m.ResetResearchCenterLevel()
		return nil
	case planet.FieldRegionCode:
		m.ResetRegionCode()
		return nil
	case planet.FieldSystemCode:
		m.ResetSystemCode()
		return nil
	case planet.FieldOrbitCode:
		m.ResetOrbitCode()
		return nil
	case planet.FieldSuborbitCode:
		m.ResetSuborbitCode()
		return nil
	case planet.FieldPositionCode:
		m.ResetPositionCode()
		return nil
	case planet.FieldName:
		m.ResetName()
		return nil
	case planet.FieldPlanetType:
		m.ResetPlanetType()
		return nil
	case planet.FieldPlanetSkin:
		m.ResetPlanetSkin()
		return nil
	case planet.FieldLastResourceUpdate:
		m.ResetLastResourceUpdate()
		return nil
	}
	return fmt.Errorf("unknown Planet field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PlanetMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.owner != nil {
		edges = append(edges, planet.EdgeOwner)
	}
	if m.timers != nil {
		edges = append(edges, planet.EdgeTimers)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PlanetMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case planet.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case planet.EdgeTimers:
		ids := make([]ent.Value, 0, len(m.timers))
		for id := range m.timers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PlanetMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedtimers != nil {
		edges = append(edges, planet.EdgeTimers)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PlanetMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case planet.EdgeTimers:
		ids := make([]ent.Value, 0, len(m.removedtimers))
		for id := range m.removedtimers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PlanetMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedowner {
		edges = append(edges, planet.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PlanetMutation) EdgeCleared(name string) bool {
	switch name {
	case planet.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PlanetMutation) ClearEdge(name string) error {
	switch name {
	case planet.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Planet unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PlanetMutation) ResetEdge(name string) error {
	switch name {
	case planet.EdgeOwner:
		m.ResetOwner()
		return nil
	case planet.EdgeTimers:
		m.ResetTimers()
		return nil
	}
	return fmt.Errorf("unknown Planet edge %s", name)
}

// SessionMutation represents an operation that mutate the Sessions
// nodes in the graph.
type SessionMutation struct {
	config
	op            Op
	typ           string
	id            *int
	token         *string
	data          *[]byte
	expiry        *time.Time
	clearedFields map[string]struct{}
}

var _ ent.Mutation = (*SessionMutation)(nil)

// newSessionMutation creates new mutation for $n.Name.
func newSessionMutation(c config, op Op) *SessionMutation {
	return &SessionMutation{
		config:        c,
		op:            op,
		typ:           TypeSession,
		clearedFields: make(map[string]struct{}),
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SessionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SessionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *SessionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetToken sets the token field.
func (m *SessionMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the token value in the mutation.
func (m *SessionMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// ResetToken reset all changes of the token field.
func (m *SessionMutation) ResetToken() {
	m.token = nil
}

// SetData sets the data field.
func (m *SessionMutation) SetData(b []byte) {
	m.data = &b
}

// Data returns the data value in the mutation.
func (m *SessionMutation) Data() (r []byte, exists bool) {
	v := m.data
	if v == nil {
		return
	}
	return *v, true
}

// ResetData reset all changes of the data field.
func (m *SessionMutation) ResetData() {
	m.data = nil
}

// SetExpiry sets the expiry field.
func (m *SessionMutation) SetExpiry(t time.Time) {
	m.expiry = &t
}

// Expiry returns the expiry value in the mutation.
func (m *SessionMutation) Expiry() (r time.Time, exists bool) {
	v := m.expiry
	if v == nil {
		return
	}
	return *v, true
}

// ResetExpiry reset all changes of the expiry field.
func (m *SessionMutation) ResetExpiry() {
	m.expiry = nil
}

// Op returns the operation name.
func (m *SessionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Session).
func (m *SessionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *SessionMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.token != nil {
		fields = append(fields, session.FieldToken)
	}
	if m.data != nil {
		fields = append(fields, session.FieldData)
	}
	if m.expiry != nil {
		fields = append(fields, session.FieldExpiry)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *SessionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case session.FieldToken:
		return m.Token()
	case session.FieldData:
		return m.Data()
	case session.FieldExpiry:
		return m.Expiry()
	}
	return nil, false
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *SessionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case session.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case session.FieldData:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetData(v)
		return nil
	case session.FieldExpiry:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiry(v)
		return nil
	}
	return fmt.Errorf("unknown Session field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *SessionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *SessionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *SessionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Session numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *SessionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *SessionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *SessionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Session nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *SessionMutation) ResetField(name string) error {
	switch name {
	case session.FieldToken:
		m.ResetToken()
		return nil
	case session.FieldData:
		m.ResetData()
		return nil
	case session.FieldExpiry:
		m.ResetExpiry()
		return nil
	}
	return fmt.Errorf("unknown Session field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *SessionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *SessionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *SessionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *SessionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *SessionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *SessionMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *SessionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Session unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *SessionMutation) ResetEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Session edge %s", name)
}

// TimerMutation represents an operation that mutate the Timers
// nodes in the graph.
type TimerMutation struct {
	config
	op            Op
	typ           string
	id            *int
	action        *timer.Action
	group         *timer.Group
	end_time      *time.Time
	clearedFields map[string]struct{}
	planet        *int
	clearedplanet bool
}

var _ ent.Mutation = (*TimerMutation)(nil)

// newTimerMutation creates new mutation for $n.Name.
func newTimerMutation(c config, op Op) *TimerMutation {
	return &TimerMutation{
		config:        c,
		op:            op,
		typ:           TypeTimer,
		clearedFields: make(map[string]struct{}),
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TimerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TimerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *TimerMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetAction sets the action field.
func (m *TimerMutation) SetAction(t timer.Action) {
	m.action = &t
}

// Action returns the action value in the mutation.
func (m *TimerMutation) Action() (r timer.Action, exists bool) {
	v := m.action
	if v == nil {
		return
	}
	return *v, true
}

// ResetAction reset all changes of the action field.
func (m *TimerMutation) ResetAction() {
	m.action = nil
}

// SetGroup sets the group field.
func (m *TimerMutation) SetGroup(t timer.Group) {
	m.group = &t
}

// Group returns the group value in the mutation.
func (m *TimerMutation) Group() (r timer.Group, exists bool) {
	v := m.group
	if v == nil {
		return
	}
	return *v, true
}

// ResetGroup reset all changes of the group field.
func (m *TimerMutation) ResetGroup() {
	m.group = nil
}

// SetEndTime sets the end_time field.
func (m *TimerMutation) SetEndTime(t time.Time) {
	m.end_time = &t
}

// EndTime returns the end_time value in the mutation.
func (m *TimerMutation) EndTime() (r time.Time, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetEndTime reset all changes of the end_time field.
func (m *TimerMutation) ResetEndTime() {
	m.end_time = nil
}

// SetPlanetID sets the planet edge to Planet by id.
func (m *TimerMutation) SetPlanetID(id int) {
	m.planet = &id
}

// ClearPlanet clears the planet edge to Planet.
func (m *TimerMutation) ClearPlanet() {
	m.clearedplanet = true
}

// PlanetCleared returns if the edge planet was cleared.
func (m *TimerMutation) PlanetCleared() bool {
	return m.clearedplanet
}

// PlanetID returns the planet id in the mutation.
func (m *TimerMutation) PlanetID() (id int, exists bool) {
	if m.planet != nil {
		return *m.planet, true
	}
	return
}

// PlanetIDs returns the planet ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// PlanetID instead. It exists only for internal usage by the builders.
func (m *TimerMutation) PlanetIDs() (ids []int) {
	if id := m.planet; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlanet reset all changes of the planet edge.
func (m *TimerMutation) ResetPlanet() {
	m.planet = nil
	m.clearedplanet = false
}

// Op returns the operation name.
func (m *TimerMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Timer).
func (m *TimerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *TimerMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.action != nil {
		fields = append(fields, timer.FieldAction)
	}
	if m.group != nil {
		fields = append(fields, timer.FieldGroup)
	}
	if m.end_time != nil {
		fields = append(fields, timer.FieldEndTime)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *TimerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case timer.FieldAction:
		return m.Action()
	case timer.FieldGroup:
		return m.Group()
	case timer.FieldEndTime:
		return m.EndTime()
	}
	return nil, false
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *TimerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case timer.FieldAction:
		v, ok := value.(timer.Action)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAction(v)
		return nil
	case timer.FieldGroup:
		v, ok := value.(timer.Group)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroup(v)
		return nil
	case timer.FieldEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	}
	return fmt.Errorf("unknown Timer field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *TimerMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *TimerMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *TimerMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Timer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *TimerMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *TimerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *TimerMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Timer nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *TimerMutation) ResetField(name string) error {
	switch name {
	case timer.FieldAction:
		m.ResetAction()
		return nil
	case timer.FieldGroup:
		m.ResetGroup()
		return nil
	case timer.FieldEndTime:
		m.ResetEndTime()
		return nil
	}
	return fmt.Errorf("unknown Timer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *TimerMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.planet != nil {
		edges = append(edges, timer.EdgePlanet)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *TimerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case timer.EdgePlanet:
		if id := m.planet; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *TimerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *TimerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *TimerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedplanet {
		edges = append(edges, timer.EdgePlanet)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *TimerMutation) EdgeCleared(name string) bool {
	switch name {
	case timer.EdgePlanet:
		return m.clearedplanet
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *TimerMutation) ClearEdge(name string) error {
	switch name {
	case timer.EdgePlanet:
		m.ClearPlanet()
		return nil
	}
	return fmt.Errorf("unknown Timer unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *TimerMutation) ResetEdge(name string) error {
	switch name {
	case timer.EdgePlanet:
		m.ResetPlanet()
		return nil
	}
	return fmt.Errorf("unknown Timer edge %s", name)
}

// UserMutation represents an operation that mutate the Users
// nodes in the graph.
type UserMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_at     *time.Time
	updated_at     *time.Time
	username       *string
	email          *string
	password       *string
	verify_token   *string
	clearedFields  map[string]struct{}
	planets        map[int]struct{}
	removedplanets map[int]struct{}
}

var _ ent.Mutation = (*UserMutation)(nil)

// newUserMutation creates new mutation for $n.Name.
func newUserMutation(c config, op Op) *UserMutation {
	return &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the created_at field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt reset all changes of the created_at field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the updated_at field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the updated_at value in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt reset all changes of the updated_at field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUsername sets the username field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the username value in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// ResetUsername reset all changes of the username field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetEmail sets the email field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the email value in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// ResetEmail reset all changes of the email field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPassword sets the password field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the password value in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// ResetPassword reset all changes of the password field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetVerifyToken sets the verify_token field.
func (m *UserMutation) SetVerifyToken(s string) {
	m.verify_token = &s
}

// VerifyToken returns the verify_token value in the mutation.
func (m *UserMutation) VerifyToken() (r string, exists bool) {
	v := m.verify_token
	if v == nil {
		return
	}
	return *v, true
}

// ClearVerifyToken clears the value of verify_token.
func (m *UserMutation) ClearVerifyToken() {
	m.verify_token = nil
	m.clearedFields[user.FieldVerifyToken] = struct{}{}
}

// VerifyTokenCleared returns if the field verify_token was cleared in this mutation.
func (m *UserMutation) VerifyTokenCleared() bool {
	_, ok := m.clearedFields[user.FieldVerifyToken]
	return ok
}

// ResetVerifyToken reset all changes of the verify_token field.
func (m *UserMutation) ResetVerifyToken() {
	m.verify_token = nil
	delete(m.clearedFields, user.FieldVerifyToken)
}

// AddPlanetIDs adds the planets edge to Planet by ids.
func (m *UserMutation) AddPlanetIDs(ids ...int) {
	if m.planets == nil {
		m.planets = make(map[int]struct{})
	}
	for i := range ids {
		m.planets[ids[i]] = struct{}{}
	}
}

// RemovePlanetIDs removes the planets edge to Planet by ids.
func (m *UserMutation) RemovePlanetIDs(ids ...int) {
	if m.removedplanets == nil {
		m.removedplanets = make(map[int]struct{})
	}
	for i := range ids {
		m.removedplanets[ids[i]] = struct{}{}
	}
}

// RemovedPlanets returns the removed ids of planets.
func (m *UserMutation) RemovedPlanetsIDs() (ids []int) {
	for id := range m.removedplanets {
		ids = append(ids, id)
	}
	return
}

// PlanetsIDs returns the planets ids in the mutation.
func (m *UserMutation) PlanetsIDs() (ids []int) {
	for id := range m.planets {
		ids = append(ids, id)
	}
	return
}

// ResetPlanets reset all changes of the planets edge.
func (m *UserMutation) ResetPlanets() {
	m.planets = nil
	m.removedplanets = nil
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.verify_token != nil {
		fields = append(fields, user.FieldVerifyToken)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldUsername:
		return m.Username()
	case user.FieldEmail:
		return m.Email()
	case user.FieldPassword:
		return m.Password()
	case user.FieldVerifyToken:
		return m.VerifyToken()
	}
	return nil, false
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldVerifyToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVerifyToken(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldVerifyToken) {
		fields = append(fields, user.FieldVerifyToken)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldVerifyToken:
		m.ClearVerifyToken()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldVerifyToken:
		m.ResetVerifyToken()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.planets != nil {
		edges = append(edges, user.EdgePlanets)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgePlanets:
		ids := make([]ent.Value, 0, len(m.planets))
		for id := range m.planets {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedplanets != nil {
		edges = append(edges, user.EdgePlanets)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgePlanets:
		ids := make([]ent.Value, 0, len(m.removedplanets))
		for id := range m.removedplanets {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgePlanets:
		m.ResetPlanets()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
